{"posts":[{"title":"Pushdown Automata and Context-free Grammar","text":"Pushdown Automata下推自动机可以看作是 NFA 加入栈后的拓展版本。与 NFA 相比，PDA 的定义中多了一个“栈”的概念，一个 PDA 由六元组 $(Q, \\Sigma, \\Gamma, \\delta, q_0, F)$ 组成。其中： $Q, \\Sigma, q_0, F$​ 与 NFA 的定义完全一致，它们分别表示状态，字符集，起始节点，接受节点集。 $\\Gamma$ 是栈字符集，它规定了栈中的每个元素可能是什么。我们常常通过往栈中压入或者弹出一个 $ 来确保当前栈是空的。 $\\delta$ 同样是转移函数，但它与 NFA 的区别是引入了栈的状态。$\\delta$ 函数接受当前状态、当前栈顶以及一个字符（当然，可以是空串 $\\epsilon$），它的输出是一个目标节点以及对当前栈的操作（不从栈顶读字符并压入一个字符、弹出一个字符、更改栈顶字符或者保持栈不动）。更为形式化地说，$\\delta$ 的定义是 $Q\\times \\Sigma_{\\epsilon}\\times \\Gamma_{\\epsilon}\\to Q\\times \\Gamma_{\\epsilon}$​（输入栈顶即将被替换的那个字符，输出新的栈顶）。 我们称字符串 $w$ 可以被这个 PDA 识别，当且仅当存在一系列状态 $s_0, \\cdots, s_m$ 以及栈构成的字符串 $t_0, \\cdots, t_m$，使得 $s_0 = q_0, t_0=\\epsilon$：一开始在起始节点；栈是空的 对于每个 $i= 0, 1, \\cdots, m-1$，存在 $a, b\\in \\Gamma_{\\epsilon}$，以及 $r\\in \\Gamma^*$ 使得 $t_i=ar, t_{i +1}=br$。且 $(s_{i+1}, b)\\in\\delta(s_i, w_{i+1},a)$。注意 $a, b$ 可以是空的，这就完成了对栈的操作。 $s_m\\in F$​，即必须在接受节点结束。 Context-free Grammar所谓上下文无关语法就是“只能通过一定规则生成”的语法。它的形式化定义由四元组 $(V,\\Sigma,R,S)$ 构成，其中： $V$ 表示变量集合。所谓“变量”，在这里指的是满足特定规则的某个字符串（可以看作里面存的就是一个字符串，但是必须满足某些限制） $\\Sigma$ 表示字符集合，它规定了字符串中可能出现的所有字符。 $R$ 是规则集合，它规定了 $V$ 中变量必须服从的规则，每条规则会将一个 $V$ 中的变量和一个包含变量以及字符的字符串结合起来。或者它也可以看作若干条“文本替换规则”，即每次将当前字符串中的一个变量替换为另一个字符串（可能包含变量）。 $S\\in V$ 表示起始变量。 我们称字符串 $w$ 能被此语法生成，当且仅当从 $S$ 能导出字符串 $w$。举个例子，考虑下面的上下文无关语法：$$G=(\\{S\\}, \\{a, b\\}, R,S)\\\\\\quad R: S\\to aSb\\ |\\ SS\\ |\\ \\epsilon$$ 它能生成 ab，abab，aabbab 等等字符串。 Corelation事实上，下推自动机和上下文无关语法是等价的。即：任意下推自动机能表示的语言都能通过某种上下文无关语法生成，任意上下文无关语法都能对应一个下推自动机。证明由两个方向进行： 1. 任意上下文无关语法都对应一个下推自动机。 2. 任意下推自动机都对应一个上下文无关语法。 可以发现，1 是较容易证明的。构造自动机的思路是，先让自动机不接受任何输入，生成所有可能的字符串堆在栈里（即每一种在自动机上的走法结束后，栈中留下的都是一种可能的字符串）。然后自动机开始接受字符串，将其与当前栈顶比较，只有二者完全相同才弹出栈。 比如上面的那个例子，对于它我们可以构造出如下自动机：用 $x, y \\to z$ 表示接受字符 $x$，取出栈顶并确认其为 $y$，向栈压入 $z$。 起始节点 $q_0$，向节点 $q_1$ 连边 $\\epsilon, \\epsilon\\to \\text{\\$}$，意思是往当前栈中压入一个特殊字符用于判断栈是否为空。 节点 $q_1$ 向节点 $q_{loop}$ 连边 $\\epsilon, \\epsilon \\to S$，这是因为起始字符是 $S$，意思是让当前字符串有一个字符 $S$。 $q_{loop}$ 的连边有两种： 如果栈顶和接受字符串的第一个字符相同，那么弹出栈顶，对应向自己的连边 $a, a\\to \\epsilon $ 以及 $b, b\\to \\epsilon$。 应用一条规则。比如规则 $S\\to aSb$，如果栈顶为 $S$，则弹出栈顶，并相继压入 b，$S$​，a。 $q_{loop}$ 向接受节点 $q_{accept}$ 连边，弹出特殊字符用来确保当前栈为空。 下图是规则 $S\\to aTb|b, T\\to Ta|\\epsilon$ 的例子。 接下来我们讨论关于 2 的证明。不妨假设这个自动机有 $k$ 个节点，我们生成 $k^2$ 个变量 $A_{pq}$，这里 $p,q$ 都是节点的编号，它用于表示所有从 $p$ 出发，并且出发时栈为空，能够到达 $q$ 且此时栈为空的字符串。那么，我们可以对其生成两种类型的规则。 存在一个中间节点 $r$，使得自动机运行到节点 $r$ 时栈为空，那么根据定义可以构造出一条语法 $A_{pq}=A_{pr}A_{rq}$。 如果存在字符串 $w$ 能从 $p$ 走到 $q$，拿出 $w$ 的第一个字符 $a$ 以及最后一个字符 $b$，并且记录下 $w$ 第一步走到的节点 $r$ 以及到达 $q$ 之前的节点 $s$，生成语法 $A_{pq}=aA_{rs}b$。由于 $\\Sigma, Q$ 都是有限的，因此这样生成的规则也只有有限多条。 通过对字符串 $w$ 的长度 $|w|$ 归纳，可以很方便地证明任意能在这个自动机上跑的字符串都能被我们构造出的语法生成。 对上下文无关语法的 Pumping Lemma Pumping Lemma 若 $A$ 是一种上下文无关语法，则存在一个数 $p$，使得对于 $A$ 能生成的任意字符串 $s$，如果 $|s| \\ge p$，那么 $s$ 可以被划分为 $5$ 个部分 $uvxyz$，使得 对于任意的 $i\\ge 0$，$uv^ixy^iz\\in A$。 $vy$ 不为空。 $|vxy|\\le p$。 只要 $s$ 足够长，那么生成出 $s$ 这个串对应的树形结构的深度就可以有保证。而这个深度一旦超过了点数，根据抽屉原理其中必然存在两个相同的变量（下图中的 $N$）。将深度更浅的 $N$ 对应的子树复制到深度更深的 $N$ 中，得到的串应当仍然满足上下文无关文法要求。","link":"/2024/03/15/Pushdown-Automata-and-Context-free-Grammar/"},{"title":"Some warm tips","text":"其实主要是一些页面元素的备忘录，我太容易搞忘了 0. 0 这个主题好像是支持 Bulma 的，也就是说可以直接向 .md 文件里面插入它支持的 html 元素。 分栏显示 这里是第一列 这里有一些内容 html code >folded123456789101112131415&lt;div class=&quot;columns&quot;&gt; &lt;div class=&quot;column&quot;&gt; &lt;article class=&quot;message is-primary&quot;&gt; &lt;div class=&quot;message-header&quot;&gt; &lt;p&gt;这里是第一列&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;message-body&quot;&gt; 这里有一些内容 &lt;/div&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; 哇，这里能递归吗 &lt;/div&gt;&lt;/div&gt; messagemessage 一共有 $7$ 种，它们分别是 dark, primary, link, info, success, warning 以及 danger。值得一提的是可以在 class 内加入 message-immersive，它会变得非常帅，比如这样 此处的代码为 12345&lt;article class=&quot;message message-immersive is-primary&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; 此处的代码为... &lt;/div&gt;&lt;/article&gt; 小标签页 第一个 第二个 我在第一个标签页里 我在第二个标签页里 12345678&lt;div class=&quot;tabs is-boxed is-fullwidth&quot;&gt; &lt;ul class=&quot;mx-0 my-0&quot;&gt; &lt;li class=&quot;is-active&quot;&gt;&lt;a href=&quot;#first&quot;&gt;第一个&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#second&quot;&gt;第二个&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div id=&quot;first&quot; class=&quot;tab-content&quot;&gt;我在第一个标签页里&lt;/div&gt;&lt;div id=&quot;second&quot; class=&quot;tab-content is-hidden&quot;&gt;我在第二个标签页里&lt;/div&gt; 代码样式可以分别制定每个代码块是否折叠，方式是采用 hexo 提供的内嵌代码，它长这样 123{% codeblock &quot;optional file name&quot; lang:code_language_name &gt;folded %}...code block content...{% endcodeblock %}","link":"/2024/03/14/Reminder/"},{"title":"Tacos lab1 directions","text":"一点碎碎念操作系统的 lab 相比于 ics 的 lab 难度明显上了一个档次，里面可能踩的坑实在是太多了！！而且对于新编写出的 rust 版本的操作系统，没有前人的足迹可以追寻，在写的时候也可能出现各种各样莫名其妙的问题。这篇文章权当一个小小的指北吧。 首先我想列出在写这个 lab 之前，我们应该达成的几点“共识”（要不然这 lab 没法写了） 多线程中常用 Mutex&lt;&gt; 来确保对关键数据访问的独一性。它有一个优点是不需要 Mutex 本身可变就可以修改里面的数据，同时可以很安全地被多个线程访问。 在这个 lab 中，我们只需要考虑单核 cpu 的情况。虽然整个系统看上去很多很多部分都是并行的，但实际上这些代码在某个时刻只会有一行正在被执行。 这个 lab 的核心是维护不同线程的切换，线程的切换涉及以下几种情况： 主动调用了 schedule 函数：将当前线程放回 ready 线程列表中，切换上下文，将执行权交给下一个线程。 一个线程被唤醒了，且它比当前正在运行的线程具有更高的优先级。 程序主动更改了一个线程的优先级（注意：这个线程一定是当前正在运行的线程！这个 lab 里面不需要实现更改其它线程的优先级），并且使得处于 ready 列表的线程中，存在一个线程的优先级更高。 一个线程请求了一个未被释放的锁。 time interrupt。在内核中有一个计时器与一个切换阈值，如果距离上次切换的时间长于这个阈值，那么操作系统会触发一次 time interrupt 陷阱。如果不关闭 time interrupt，这个陷阱内会执行一次 schedule。因此如果要从系统层面上确保当前操作是原子的，需要关闭 time interrupt（关上这个之后甚至连 tick 都不会调用）。每个线程都有自己独立的 time interrupt 状态。在多核 cpu 上频繁地关 interrupt 不是一个好习惯，因为所有 cpu 都会停下，效率很低。不过我们只需要考虑单核的情况，因此该关还是关吧。 关于 CondVar：在使用互斥锁的场景下，如果我们手持一个锁，但同时又想要等待另外一个锁被释放，此时有两种想法： 不释放当前手持的锁，等待被释放的锁。好处是不会产生数据竞争，但是此时任何其他需要第一个锁的线程都会被阻塞，这样效率不高。 释放当前手持的锁，等待被释放的锁。这样做有一定风险：等待此线程持有的锁的那些线程有可能会在中间插入，从而导致数据竞争。 CondVar 就是专门针对这样的场景设计的工具，核心部分由三个函数组成： wait(cond, guard) 这里 cond 是条件变量，guard 是锁，且必须处于持有状态。这个函数可以理解为“释放锁 guard，等待条件变量 cond 被触发，再重新获取锁 guard” 的原子过程，尽管其内部实现并不是原子的。 notify_one(cond) 通知一个等待这个条件变量触发的线程。如果没有线程在等待，那么这次触发将会被丢失。 notify_all(cond) 通知所有正在等待这个变量触发的线程。 可以说从头到尾，这个 lab 有几个核心之处： src/thread.rs，这个文件内实现了 thread 的所有接口。我修改了 wake_up, sleep, get_priority, set_priority 这些函数。我们需要实现让线程能非阻塞 sleep，以及能够设置当前线程的优先级。 src/thread/manager.rs，这个文件内实现了函数 schedule，可以说这是整个 lab 最为核心的函数：操作系统从 ready 列表中拿出优先级最高的线程，停止执行当前线程，切换上下文并移交执行权。 src/thread/imp.rs，这个文件内是线程各项属性的定义，为了实现 task2 的第二部分我们需要对线程本身的结构体做出很多修改。 已经实现好的各种锁的代码。由于我们需要向线程切换以及唤醒线程中加入优先级的概念，因此所有涉及“唤醒等待线程”的地方都要考虑它们的优先级。 最后说一说调试方法。我还是最喜欢直接 kprintln。可以在 schedule 函数、设置优先级这些地方输出当前线程的信息，非常方便。由于 rust 的 release 编译非常非常慢，因此要调试测试数据的时候可以先加入参数 --dry 显示调用的命令，然后在根目录下手动执行这个命令。这样可以快很多。 比如，如果我想要调试测试点 priority-preempt，我就可以在 tool 文件夹里面输入命令 cargo tt -c priority-preempt --dry，它的输出是这样的","link":"/2024/03/18/Tacos-lab1-directions/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/03/14/hello-world/"}],"tags":[{"name":"Automata","slug":"Automata","link":"/tags/Automata/"},{"name":"Theoretical Computer Science (TCS)","slug":"Theoretical-Computer-Science-TCS","link":"/tags/Theoretical-Computer-Science-TCS/"},{"name":"Operating System","slug":"Operating-System","link":"/tags/Operating-System/"}],"categories":[{"name":"Theoretical Computer Science(TCS)","slug":"Theoretical-Computer-Science-TCS","link":"/categories/Theoretical-Computer-Science-TCS/"},{"name":"Configuration","slug":"Configuration","link":"/categories/Configuration/"},{"name":"Operating System","slug":"Operating-System","link":"/categories/Operating-System/"},{"name":"Automata","slug":"Theoretical-Computer-Science-TCS/Automata","link":"/categories/Theoretical-Computer-Science-TCS/Automata/"}],"pages":[{"title":"About","text":"哇，恭喜你发现了这个神奇的角落！","link":"/about/index.html"}]}