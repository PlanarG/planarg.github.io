{"posts":[{"title":"Fragment of my Fantasy","text":"有感而发的小东西，点子不错，文笔有限。 夜曲老人递给陆启明一架小马扎，招呼他坐下。老人的声音微微颤抖着，那双爬满皱纹的大手却沉稳有力。陆启明接过板凳靠窗坐下，壁炉内噼啪燃烧的木柴让他感觉到些许温暖，他不由地出了神。行囊已经打点妥当，卸下沉甸甸的小型mu-介子探测器后，他的双肩轻松了许多。这些仪器都是陆启明费了好大劲才从研究所物资保管室里折腾出来的，他由衷地希望这些天的探测能让它们物有所值。 “这年头，来这地方的年轻人可不多见喽”，老人的话将陆启明从思绪中拉了回来。自从科威特科考站设立已经过去了百余个年头，在拔地而起的高强度纤维结织而成的楼房内居住的人们早已不用抱膝在炉火前颤栗在寒冷的风中。一如陆启明所料，这栋小屋仍然维持着原样——至少和导师描述中的那栋小屋别无二致，但令他欣喜是，老人依然在照料着这里。当三十年前的导师刚踏上这片孤独的土地时，在这座与世隔绝的小屋内，老人是否也和他有过同样的对话？ “法格答尔火山最近正处于活跃期，您在这里待了这么长时间，一定目睹过它的无数次喷发吧”。陆启明望向窗外，如冰川般淡蓝色的天空被夕阳染红了半边，零星点缀在永久冻土上的皑皑白雪在余光中闪烁，蜿蜒伸向远方的公路是可视范围内唯一的人造物。法格答尔火山静穆在公路消失的那一头，在与之接壤，洒满金黄色辉光的国家地质公园旁显得格外暗淡。不过陆启明提醒着自己，这里可是整个北半球地质活动最为活跃的地区，光是一个月内有明显震感的地震就不下百次。 “那是当然。我对这火山就像对自己的脉搏一样熟悉，”老人爽朗的笑声似乎轻轻触动到了陆启明心中的什么，“运气好的话咱们今晚就能目睹一次喷发。” 老人给年轻人斟满茶，屋子渐渐暖和了起来。他们聊起了这栋小屋的过去，聊起了三十年前的导师，老人笑眯眯地称赞说那是一个相当有趣的小伙子，他们一起丈量了方圆百里内的每一寸土地。年轻人激动地向老人讲述他的研究课题，老人说他还记得当年便携式钻探工具的模样，那双安装过无数次固定螺栓、记录过无数测绘数据的手，不会忘记与土地对话的感觉。温馨的小屋内时间总是流逝得格外迅速。 天色完全暗了下来，起初是远处零星的暗红色火光吸引了陆启明的注意，当他抬头正视，刺目的岩浆在火山口飞溅爆裂，寂静的暗夜被硬生生烫出了一个洞。灼热的深灰色烟雾在火光中摇摆翻腾，罩住了整片冻原，这舞台的帷幕，仅有大地一位演员。陆启明发现自己已经站起身来。老人铁一般瘦削的身影被映得赤红，雪原上的一切都在飞速地离陆启明而去，只有那颗不规则的巨大心脏在搏动。闪烁的岩浆流挟着浓烟沿着山脊流淌，扑面而来的高温与气浪让陆启明无需借用黑体辐射的铁律也能感知到其磅礴的能量。他幻想着自己是在宇宙中心蜷缩着的光的婴儿，无声的啼哭使无数恒星为之黯淡。一切太安静了，出奇地安静。强烈的眩晕感让陆启明有那么一瞬间怀疑这一切的真实性——安静的婴儿，无声的啼哭，就像一场梦一般。 就像一场栖息在心底的、遥远的梦。 陆启明似乎又回到了那天傍晚，窗外的街道如玩具般被撕裂开来，那是他每日上学都必经的街道。他眼睁睁地看着一辆印着汰渍洗衣液广告的双层公交车失速坠入，后排乘客在消失在视线内的那一刻摇下车窗。他小时候很爱弹钢琴，他喜欢听那些由小小的黑白琴键交织而成的宏伟乐曲，喜欢榔头轻击在琴弦上发出的清脆乐音。钢琴猛然倒地，琴键砸向地面的刺耳声音让他吓了一跳。父母抱着他冲出了楼房，一台坠落的空调外机却夺去了他最好的朋友的生命。轰然倒塌，烟尘弥散，夕阳的余晖穿不透这滚滚浓烟，他什么也看不见。 在高考填报志愿的时候，他不加思索直接选择了地球物理专业。他常常梦见那个傍晚，那辆公交车，那个最好的朋友。琴弦崩坏的杂音让他辗转反侧，是啊，他畏惧着大地，怕得发抖。哺育一切的大地，势如洪流般摧毁一切的大地，是一种怎样的存在？ “别盯着火山口看太久，很伤眼睛的”。老人轻轻叹了口气，丢给陆启明一副墨镜，示意他在身旁坐下，他知道陆启明的眼中闪烁着的是什么。“三十年前的我和你如出一辙，那时候地质学的发展已经趋于停滞，任何对于解读长程地质活动的努力均以失败告终，再也没有新的理论被提出了。这领域越是深入，你越会觉得，其实自己对地球一无所知，直到我遇见了你的导师，”老人抬起头，远处的火光在他的眼中跃动。 “是时候给你讲讲落日工程的故事了。” 三十年前，科学界已经掌握用可控小型核爆与特殊材料“糖衣”稳定制造高密度中子材料的技术。核爆产生的巨大向心压力，被“糖衣”均匀地分配至里面包裹的物质表面，得到的物质甚至能在固态的岩石中下沉。后来的落日一号至计划发射的落日十号飞船的主体正是这种材料，只不过发射的目标不是星辰大海，而是地心深处。 陆启明对这个故事的开头再熟悉不过。最美丽的花草都被人们放在肃穆的落日六号纪念碑前，透过树荫的霞光将纪念碑的影子拉得狭长。纪念公园离他的大学很近，他闲暇时常去那里坐坐。秋日的公园宁静而祥和，要是迷失在地心的落日六号领航员沈静前辈也能伸出手指轻抚这里的微风，那该多好。但令人遗憾的是，落日七号至十号却因为工程原因被无限期地搁置。 “我想告诉你的，是在落日一号之前的那些故事。” “三十年前，我和你的导师相遇了。当时你的导师正在实验室里对着几篇打印出的论文发火，它们是其他学者发表在地质预测会议上面的。我翻了翻这几篇论文，都是一些对于现有基于地表观测数据的模型的精细修改。我记不太清这些论文的具体细节了，听说过本轮和均轮吗？” 陆启明摇头。老人挥了挥手，“也罢，现在还记得这几个词的都成老古董了。只是经过那几篇论文的轮番修改，原本的模型已经变得臃肿不堪。他当时都不屑于复现那些论文，我跟另外几位博士在科研之余试了试，发现这些修改确实在1到2年的周期内在划定的小规模区域内都能达到非常精确的预测结果，但一旦将时间跨度拉长，误差就会大到和随机无异了。” 清冽的月光织出一条白银缎带，泛着微微深红的火山岩尚有余温，大地似乎又沉沉睡去。“你的导师是对的，他的直觉总是能达到令人恐怖的准确率。我们发现理论的每次预测失效都在新出现的大火山的活动周期内，一旦产生了这样的偏差，后续预测便再难准确。” “后来，我带他来这个远在北极圈内的科考站逛逛。那次我们在这里待了老长一段时间，这儿可是潜心研究的好地方，不过你的导师似乎有些别的看法…直到有一天，我们近距离目睹了法格答尔火山的喷发。” “尽管那一次的喷发比我们刚刚看到的规模要小不少，但他却直接坐在地上，望着火山口沉默良久，初春时这里的积雪都还没完全化干净。当我想从包里拿出一张折叠椅递给他时，他回头直勾勾地看着我。” “他少见地直呼我的名字，‘也许我们的方向一直错了，’他支起身来，我清晰地记得他的裤子被体温融化的积雪沾湿了大片，但他却将身体挺的笔直，‘我们这么多年，这么多学者观测到的数据都只不过是…’” “….都只不过是地核之中岩浆和铁镍流体相互作用在地表上形成的的具象，对它们的测量再如何精确，也仅仅是在肢体末端测量人的脉搏而已。”陆启明轻轻点头，导师的音容相貌又重被从记忆中拾起，他不由地长叹一声。 “精妙的比喻。正是怀揣着这样的想法，国家地核物理实验室成立了，你的导师担任第一任首席科学顾问。他们规划着设计一系列耐极高温、高灵敏度的流体动力学探测器，并将它们发往地心，通过不受干扰的中微子通信收集数据，进而设计数学模型尝试推算整个地球的地质运动。这个计划后来更名为，落日工程。” “啊，但我记得落日工程的第一任 CTO 是…” 老人摇了摇头，“当落日工程启动的时候，他已经离我们而去”。 陆启明抬头望向天空，火山的余烬已然褪去，在这里能看见北半球最为浩瀚的星空。参宿四和参宿七张成一张巨弓，湛蓝的三颗腰带正如蓄势待发射向大犬座的弓箭——陆启明很喜欢将它们当作弓箭。天狼星无疑是大犬座中最耀眼的一颗，群青色的辉光弥散在夜幕中。银河如天龙一般横跨苍穹，无数恒星的色彩穿透星云凝固在整片夜空上。陆启明深知自己正处于远离城市光源的荒原，在这片静谧之地，他的心情却波澜起伏。 第二天清晨，陆启明背上背包早早地就出发了。老人又斟了一杯热茶为他送行。“祝愿你能在这里找到导师毕生追求的东西。”临行前老人意味深长地看着他。 小屋冒出的一缕炊烟让陆启明忽然有种言说不出的感动，陆启明反复品味着老人的目光。","link":"/2024/03/24/Fragment-of-my-Fantasy/"},{"title":"Pushdown Automata and Context-free Grammar","text":"Pushdown Automata下推自动机可以看作是 NFA 加入栈后的拓展版本。与 NFA 相比，PDA 的定义中多了一个“栈”的概念，一个 PDA 由六元组 $(Q, \\Sigma, \\Gamma, \\delta, q_0, F)$ 组成。其中： $Q, \\Sigma, q_0, F$​ 与 NFA 的定义完全一致，它们分别表示状态，字符集，起始节点，接受节点集。 $\\Gamma$ 是栈字符集，它规定了栈中的每个元素可能是什么。我们常常通过往栈中压入或者弹出一个 $ 来确保当前栈是空的。 $\\delta$ 同样是转移函数，但它与 NFA 的区别是引入了栈的状态。$\\delta$ 函数接受当前状态、当前栈顶以及一个字符（当然，可以是空串 $\\epsilon$），它的输出是一个目标节点以及对当前栈的操作（不从栈顶读字符并压入一个字符、弹出一个字符、更改栈顶字符或者保持栈不动）。更为形式化地说，$\\delta$ 的定义是 $Q\\times \\Sigma_{\\epsilon}\\times \\Gamma_{\\epsilon}\\to Q\\times \\Gamma_{\\epsilon}$​（输入栈顶即将被替换的那个字符，输出新的栈顶）。 我们称字符串 $w$ 可以被这个 PDA 识别，当且仅当存在一系列状态 $s_0, \\cdots, s_m$ 以及栈构成的字符串 $t_0, \\cdots, t_m$，使得 $s_0 = q_0, t_0=\\epsilon$：一开始在起始节点；栈是空的 对于每个 $i= 0, 1, \\cdots, m-1$，存在 $a, b\\in \\Gamma_{\\epsilon}$，以及 $r\\in \\Gamma^*$ 使得 $t_i=ar, t_{i +1}=br$。且 $(s_{i+1}, b)\\in\\delta(s_i, w_{i+1},a)$。注意 $a, b$ 可以是空的，这就完成了对栈的操作。 $s_m\\in F$​，即必须在接受节点结束。 Context-free Grammar所谓上下文无关语法就是“只能通过一定规则生成”的语法。它的形式化定义由四元组 $(V,\\Sigma,R,S)$ 构成，其中： $V$ 表示变量集合。所谓“变量”，在这里指的是满足特定规则的某个字符串（可以看作里面存的就是一个字符串，但是必须满足某些限制） $\\Sigma$ 表示字符集合，它规定了字符串中可能出现的所有字符。 $R$ 是规则集合，它规定了 $V$ 中变量必须服从的规则，每条规则会将一个 $V$ 中的变量和一个包含变量以及字符的字符串结合起来。或者它也可以看作若干条“文本替换规则”，即每次将当前字符串中的一个变量替换为另一个字符串（可能包含变量）。 $S\\in V$ 表示起始变量。 我们称字符串 $w$ 能被此语法生成，当且仅当从 $S$ 能导出字符串 $w$。举个例子，考虑下面的上下文无关语法：$$G=(\\{S\\}, \\{a, b\\}, R,S)\\\\\\quad R: S\\to aSb\\ |\\ SS\\ |\\ \\epsilon$$ 它能生成 ab，abab，aabbab 等等字符串。 Corelation事实上，下推自动机和上下文无关语法是等价的。即：任意下推自动机能表示的语言都能通过某种上下文无关语法生成，任意上下文无关语法都能对应一个下推自动机。证明由两个方向进行： 1. 任意上下文无关语法都对应一个下推自动机。 2. 任意下推自动机都对应一个上下文无关语法。 可以发现，1 是较容易证明的。构造自动机的思路是，先让自动机不接受任何输入，生成所有可能的字符串堆在栈里（即每一种在自动机上的走法结束后，栈中留下的都是一种可能的字符串）。然后自动机开始接受字符串，将其与当前栈顶比较，只有二者完全相同才弹出栈。 比如上面的那个例子，对于它我们可以构造出如下自动机：用 $x, y \\to z$ 表示接受字符 $x$，取出栈顶并确认其为 $y$，向栈压入 $z$。 起始节点 $q_0$，向节点 $q_1$ 连边 $\\epsilon, \\epsilon\\to \\text{\\$}$，意思是往当前栈中压入一个特殊字符用于判断栈是否为空。 节点 $q_1$ 向节点 $q_{loop}$ 连边 $\\epsilon, \\epsilon \\to S$，这是因为起始字符是 $S$，意思是让当前字符串有一个字符 $S$。 $q_{loop}$ 的连边有两种： 如果栈顶和接受字符串的第一个字符相同，那么弹出栈顶，对应向自己的连边 $a, a\\to \\epsilon $ 以及 $b, b\\to \\epsilon$。 应用一条规则。比如规则 $S\\to aSb$，如果栈顶为 $S$，则弹出栈顶，并相继压入 b，$S$​，a。 $q_{loop}$ 向接受节点 $q_{accept}$ 连边，弹出特殊字符用来确保当前栈为空。 下图是规则 $S\\to aTb|b, T\\to Ta|\\epsilon$ 的例子。 接下来我们讨论关于 2 的证明。不妨假设这个自动机有 $k$ 个节点，我们生成 $k^2$ 个变量 $A_{pq}$，这里 $p,q$ 都是节点的编号，它用于表示所有从 $p$ 出发，并且出发时栈为空，能够到达 $q$ 且此时栈为空的字符串。那么，我们可以对其生成两种类型的规则。 存在一个中间节点 $r$，使得自动机运行到节点 $r$ 时栈为空，那么根据定义可以构造出一条语法 $A_{pq}=A_{pr}A_{rq}$。 如果存在字符串 $w$ 能从 $p$ 走到 $q$，拿出 $w$ 的第一个字符 $a$ 以及最后一个字符 $b$，并且记录下 $w$ 第一步走到的节点 $r$ 以及到达 $q$ 之前的节点 $s$，生成语法 $A_{pq}=aA_{rs}b$。由于 $\\Sigma, Q$ 都是有限的，因此这样生成的规则也只有有限多条。 通过对字符串 $w$ 的长度 $|w|$ 归纳，可以很方便地证明任意能在这个自动机上跑的字符串都能被我们构造出的语法生成。 对上下文无关语法的 Pumping Lemma Pumping Lemma 若 $A$ 是一种上下文无关语法，则存在一个数 $p$，使得对于 $A$ 能生成的任意字符串 $s$，如果 $|s| \\ge p$，那么 $s$ 可以被划分为 $5$ 个部分 $uvxyz$，使得 对于任意的 $i\\ge 0$，$uv^ixy^iz\\in A$。 $vy$ 不为空。 $|vxy|\\le p$。 只要 $s$ 足够长，那么生成出 $s$ 这个串对应的树形结构的深度就可以有保证。而这个深度一旦超过了点数，根据抽屉原理其中必然存在两个相同的变量（下图中的 $N$）。将深度更浅的 $N$ 对应的子树复制到深度更深的 $N$ 中，得到的串应当仍然满足上下文无关文法要求。","link":"/2024/03/15/Pushdown-Automata-and-Context-free-Grammar/"},{"title":"Some warm tips","text":"其实主要是一些页面元素的备忘录，我太容易搞忘了 0. 0 这个主题好像是支持 Bulma 的，也就是说可以直接向 .md 文件里面插入它支持的 html 元素。 分栏显示 这里是第一列 这里有一些内容 html code >folded123456789101112131415&lt;div class=&quot;columns&quot;&gt; &lt;div class=&quot;column&quot;&gt; &lt;article class=&quot;message is-primary&quot;&gt; &lt;div class=&quot;message-header&quot;&gt; &lt;p&gt;这里是第一列&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;message-body&quot;&gt; 这里有一些内容 &lt;/div&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; 哇，这里能递归吗 &lt;/div&gt;&lt;/div&gt; messagemessage 一共有 $7$ 种，它们分别是 dark, primary, link, info, success, warning 以及 danger。值得一提的是可以在 class 内加入 message-immersive，它会变得非常帅，比如这样 此处的代码为 12345&lt;article class=&quot;message message-immersive is-primary&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; 此处的代码为... &lt;/div&gt;&lt;/article&gt; 小标签页 第一个 第二个 我在第一个标签页里 我在第二个标签页里 12345678&lt;div class=&quot;tabs is-boxed is-fullwidth&quot;&gt; &lt;ul class=&quot;mx-0 my-0&quot;&gt; &lt;li class=&quot;is-active&quot;&gt;&lt;a href=&quot;#first&quot;&gt;第一个&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#second&quot;&gt;第二个&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div id=&quot;first&quot; class=&quot;tab-content&quot;&gt;我在第一个标签页里&lt;/div&gt;&lt;div id=&quot;second&quot; class=&quot;tab-content is-hidden&quot;&gt;我在第二个标签页里&lt;/div&gt; 代码样式可以分别制定每个代码块是否折叠，方式是采用 hexo 提供的内嵌代码，它长这样 123{% codeblock &quot;optional file name&quot; lang:code_language_name &gt;folded %}...code block content...{% endcodeblock %} 插入图片在文件中加入如下代码 1{% asset_img image.jpg 200 400 This is an image %} 其中 200 400 的作用是限制图片大小。","link":"/2024/03/14/Reminder/"},{"title":"Tacos lab1 directions","text":"一点碎碎念操作系统的 lab 相比于 ics 的 lab 难度明显上了一个档次，里面可能踩的坑实在是太多了！！而且对于新编写出的 rust 版本的操作系统，没有前人的足迹可以追寻，在写的时候也可能出现各种各样莫名其妙的问题。这篇文章权当一个小小的指北吧。我只会列出每个任务的设计思路。 首先我想列出在写这个 lab 之前，我们应该达成的几点“共识”（要不然这 lab 没法写了） 多线程中常用 Mutex&lt;&gt; 来确保对关键数据访问的独一性。它有一个优点是不需要 Mutex 本身可变就可以修改里面的数据，同时可以很安全地被多个线程访问。 std 是没法用的，但是 rust 很贴心地帮我们在 alloc 里面实现了很多有用的工具，比如 Vec, BinaryHeap, BTreeMap 等等。需要注意的是 rust 中没有与 multiset 类似的数据结构。 在这个 lab 中，我们只需要考虑单核 cpu 的情况。虽然整个系统看上去很多很多部分都是并行的，但实际上这些代码在某个时刻只会有一行正在被执行。 这个 lab 的核心是维护不同线程的切换，线程的切换涉及以下几种情况： 主动调用了 schedule 函数：将当前线程放回 ready 线程列表中，切换上下文，将执行权交给下一个线程。 一个线程被唤醒了，且它比当前正在运行的线程具有更高的优先级。 程序主动更改了一个线程的优先级（注意：这个线程一定是当前正在运行的线程！这个 lab 里面不需要实现更改其它线程的优先级），并且使得处于 ready 列表的线程中，存在一个线程的优先级更高。 一个线程请求了一个未被释放的锁。 time interrupt。在内核中有一个计时器与一个切换阈值，如果距离上次切换的时间长于这个阈值，那么操作系统会触发一次 time interrupt 陷阱。如果不关闭 time interrupt，这个陷阱内会执行一次 schedule。因此如果要从系统层面上确保当前操作是原子的，需要关闭 time interrupt（关上这个之后甚至连 tick 都不会调用）。每个线程都有自己独立的 time interrupt 状态。在多核 cpu 上频繁地关 interrupt 不是一个好习惯，因为所有 cpu 都会停下，效率很低。不过我们只需要考虑单核的情况，因此该关还是关吧。 关于 CondVar：在使用互斥锁的场景下，如果我们手持一个锁，但同时又想要等待另外一个锁被释放，此时有两种想法： 不释放当前手持的锁，等待被释放的锁。好处是不会产生数据竞争，但是此时任何其他需要第一个锁的线程都会被阻塞，这样效率不高。 释放当前手持的锁，等待被释放的锁。这样做有一定风险：等待此线程持有的锁的那些线程有可能会在中间插入，从而导致数据竞争。 CondVar 就是专门针对这样的场景设计的工具，核心部分由三个函数组成： wait(cond, guard) 这里 cond 是条件变量，guard 是锁，且必须处于持有状态。这个函数可以理解为“释放锁 guard，等待条件变量 cond 被触发，再重新获取锁 guard” 的原子过程，尽管其内部实现并不是原子的。 notify_one(cond) 通知一个等待这个条件变量触发的线程。如果没有线程在等待，那么这次触发将会被丢失。 notify_all(cond) 通知所有正在等待这个变量触发的线程。 可以说从头到尾，这个 lab 有几个核心之处： src/thread.rs，这个文件内实现了 thread 的所有接口。我修改了 wake_up, sleep, get_priority, set_priority 这些函数。我们需要实现让线程能非阻塞 sleep，以及能够设置当前线程的优先级。 src/thread/manager.rs，这个文件内实现了函数 schedule，可以说这是整个 lab 最为核心的函数：操作系统从 ready 列表中拿出优先级最高的线程，停止执行当前线程，切换上下文并移交执行权。 src/thread/imp.rs，这个文件内是线程各项属性的定义，为了实现 task2 的第二部分我们需要对线程本身的结构体做出很多修改。 已经实现好的各种锁的代码。由于我们需要向线程切换以及唤醒线程中加入优先级的概念，因此所有涉及“唤醒等待线程”的地方都要考虑它们的优先级。 最后说一说调试方法。我还是最喜欢直接 kprintln。可以在 schedule 函数、设置优先级这些地方输出当前线程的信息，非常方便。由于 rust 的 release 编译非常非常慢，因此要调试测试数据的时候可以先加入参数 --dry 显示调用的命令，然后在根目录下手动执行这个命令。这样可以快很多。 比如，如果我想要调试测试点 priority-preempt，我就可以在 tool 文件夹里面输入命令 cargo tt -c priority-preempt --dry，它的输出是这样的 在根目录下运行命令 cargo run -r -F test-schedule -- -append priority-preempt 就可以了。-q 参数可删可不删，我觉得看着编译信息有一种它正在工作的感觉。 Alarm Clock这个 task 的意思是需要让我们更改原有的 sleep 函数。这个函数默认的实现方式是每次被唤醒的时候就看看当前时刻有没有到目标时刻，如果没有到话就 schedule，让 cpu 执行其它线程。我们需要把它改为非阻塞的实现方式。 实现方式也很简单，可以发现整个操作系统有一个增加当前时刻的函数 tick，我们只需要让这个函数每次被调用的时候都检查一下当前正在等待的线程。可以用 BTreeMap&lt;i64, Vec&lt;Arc&lt;Thread&gt;&gt;&gt; 将线程唤醒时间与线程本身关联起来，每 tick 都检查一下当前正在 sleep 的线程列表。 Priority SchedulingBasic Priority Scheduling这里我们需要实现简单的线程优先级系统，为了确保我们对于优先级的理解正确，以下有几点共识： 操作系统在任意时刻正在运行的线程都一定具有最高的优先级。不存在一个有着更高优先级的线程位于等待列表中。 对于相同优先级的线程，在 schedule 中需要采用先进先出的策略：先被添加到 ready 列表中的线程应当被优先唤醒。 在信号量中优先唤醒优先级高的线程。但是对于相同优先级的线程，它们被唤醒的顺序可以是随机的。 为了让程序有更高的运行效率，你可能会想到用 BinaryHeap 实现取出优先级最高的线程，但是相信我，下一个任务你会把它改回 Vec 的（或者 VecDeque） 推荐在写这个部分之前先认真思考一下这几个问题： 每个线程可能有哪些状态？ 什么时候线程有可能会调用 set_priority？需不需要考虑那些正在被 Blocked 的线程？ 什么时候最高优先级的线程会发生变化？ 你会需要修改 src/thread/scheduler/fcfs.rs 文件，可以照着里面已经有的那个东西实现一个优先队列版本的。 值得一提的是我发现 src/sync/sema.rs 中对 up 函数的默认实现似乎有点问题： src/sync/sema.rs1234567891011121314/// V operationpub fn up(&amp;self) { let old = sbi::interrupt::set(false); let count = self.value.replace(self.value() + 1); // Check if we need to wake up a sleeping waiter if let Some(thread) = self.waiters.borrow_mut().pop_back() { assert_eq!(count, 0); thread::wake_up(thread.clone()); } sbi::interrupt::set(old);} 这里实际上是不能 assert 的：唤醒线程并不代表立即运行这个线程，而 count 只有在请求锁的线程开始运行的时候才会 $-1$。因此如果执行权没有被交给被唤醒的线程，进行相邻的两次 V 后 count 确实可能非 $0$。所以这里的 assert 需要删去。 Priority Donation聪明的你在写完上一个关于优先级的任务之后也许会有这样的疑问：诶？这样的规则是不是非常容易导致死锁？文档中描述了这样一种情况：假设现在有高优先级线程 H，中优先级线程 M 以及低优先级线程 L，如果 L 持有一个锁，而 M 正在运行，那么 L 这个线程无论如何也不会被启动（因为 M 的优先级高于它，根据优先级策略 M 应该被优先执行），如果 H 需要 L 的锁，那么它就完蛋了。 为了让这种情况不要发生，文档中提出了一种“线程捐赠”的机制：如果线程 A 要请求线程 B 的锁，它就会把自己的优先级“捐”给 B：B 此时的优先级应当变为 A，B 两者的较大值。我们将这个值称为“有效优先级”。如果 B 又开始请求线程 C 的锁，那么 B 就会把自己的有效优先级捐给 C，此时 C 的优先级就是 A，B，C 三者的最大值。 你仔细思考了一下，发现很难在信号量这种多对多的场景实现这样的线程捐赠机制：你怎么知道当前线程在 P 完之后或者 V 完之后会不会继续管这个信号量？即使它不会管，也有许许多多其它的线程有可能会 V。那这种情况是谁捐给谁呢？ 答案是其实我们不需要管这种情况。只需要实现最简单的 sleep 内（不是第一个任务里面的那个 sleep）的优先级捐赠情况就行了，它相当于只能为 0 或者为 1 的信号量。sleep 内是一对多的（一个 holder，多个 waiter）。 如果把线程捐赠的网络画成一张图，首先它一定是一个 DAG，再思考一下会发现它一定是一棵树：每个线程只可能等待另外一个线程，因为一旦 require 失败它就会 Block 直到这个锁被释放。因此我们需要实现的东西就是维护这么一棵捐赠的树形结构：可能会连一条新的边，也有可能断开原有的边，每个点的有效优先级是子树内的最大值。如果你非常厉害，那么不妨来试试 lct 吧。 需要注意的是由于我们可能会请求一个正在 sleep 或者正在被阻塞的线程所持有的锁，所以那些没有运行的程序的优先级，乃至整条链上的优先级都可能会被改变，这也是上一个任务中不能使用 BinaryHeap 的原因：它是不支持修改的。 另一件令人迷惑的问题是，我们需要在即使只有 Arc&lt;Thread&gt; 的情况下也能对此线程内的依赖关系进行修改，这就要求我们给那些可能被修改的数据套上互斥锁（RefCell 是不行的，因为它不 Sync，多线程访问的话 rust 会觉得不安全），这是相当奇怪的一件事：在上锁的过程中会涉及优先级捐赠，但实现优先级捐赠的部分却需要上锁。实际上在涉及到更改捐赠树的操作时我们会关闭 interrupt，因此可以确保访问的唯一性，但是为了通过编译仍然需要在相关的数据结构外套上一层 Mutex。 最后聊一聊 acquire 和 release 内具体要干的事情。","link":"/2024/03/18/Tacos-lab1-directions/"}],"tags":[{"name":"Automata","slug":"Automata","link":"/tags/Automata/"},{"name":"Theoretical Computer Science (TCS)","slug":"Theoretical-Computer-Science-TCS","link":"/tags/Theoretical-Computer-Science-TCS/"},{"name":"Operating System","slug":"Operating-System","link":"/tags/Operating-System/"}],"categories":[{"name":"Theoretical Computer Science(TCS)","slug":"Theoretical-Computer-Science-TCS","link":"/categories/Theoretical-Computer-Science-TCS/"},{"name":"Configuration","slug":"Configuration","link":"/categories/Configuration/"},{"name":"Automata","slug":"Theoretical-Computer-Science-TCS/Automata","link":"/categories/Theoretical-Computer-Science-TCS/Automata/"},{"name":"Operating System","slug":"Operating-System","link":"/categories/Operating-System/"}],"pages":[{"title":"About","text":"哇，恭喜你发现了这个神奇的角落！ 但可惜的是，现在这里还啥都没有…🥲","link":"/about/index.html"}]}