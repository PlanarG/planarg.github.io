{"posts":[{"title":"Fragment of my Fantasy","text":"有感而发的小东西，点子不错，文笔有限。 夜曲老人递给陆启明一架小马扎，招呼他坐下。老人的声音微微颤抖着，那双爬满皱纹的大手却沉稳有力。陆启明接过板凳靠窗坐下，壁炉内噼啪燃烧的木柴让他感觉到些许温暖，他不由地出了神。行囊已经打点妥当，卸下沉甸甸的小型mu-介子探测器后，他的双肩轻松了许多。这些仪器都是陆启明费了好大劲才从研究所物资保管室里折腾出来的，他由衷地希望这些天的探测能让它们物有所值。 “这年头，来这地方的年轻人可不多见喽”，老人的话将陆启明从思绪中拉了回来。自从科威特科考站设立已经过去了百余个年头，在拔地而起的高强度纤维结织而成的楼房内居住的人们早已不用抱膝在炉火前颤栗在寒冷的风中。一如陆启明所料，这栋小屋仍然维持着原样——至少和导师描述中的那栋小屋别无二致，但令他欣喜是，老人依然在照料着这里。当三十年前的导师刚踏上这片孤独的土地时，在这座与世隔绝的小屋内，老人是否也和他有过同样的对话？ “法格答尔火山最近正处于活跃期，您在这里待了这么长时间，一定目睹过它的无数次喷发吧”。陆启明望向窗外，如冰川般淡蓝色的天空被夕阳染红了半边，零星点缀在永久冻土上的皑皑白雪在余光中闪烁，蜿蜒伸向远方的公路是可视范围内唯一的人造物。法格答尔火山静穆在公路消失的那一头，在与之接壤，洒满金黄色辉光的国家地质公园旁显得格外暗淡。不过陆启明提醒着自己，这里可是整个北半球地质活动最为活跃的地区，光是一个月内有明显震感的地震就不下百次。 “那是当然。我对这火山就像对自己的脉搏一样熟悉，”老人爽朗的笑声似乎轻轻触动到了陆启明心中的什么，“运气好的话咱们今晚就能目睹一次喷发。” 老人给年轻人斟满茶，屋子渐渐暖和了起来。他们聊起了这栋小屋的过去，聊起了三十年前的导师，老人笑眯眯地称赞说那是一个相当有趣的小伙子，他们一起丈量了方圆百里内的每一寸土地。年轻人激动地向老人讲述他的研究课题，老人说他还记得当年便携式钻探工具的模样，那双安装过无数次固定螺栓、记录过无数测绘数据的手，不会忘记与土地对话的感觉。温馨的小屋内时间总是流逝得格外迅速。 天色完全暗了下来，起初是远处零星的暗红色火光吸引了陆启明的注意，当他抬头正视，刺目的岩浆在火山口飞溅爆裂，寂静的暗夜被硬生生烫出了一个洞。灼热的深灰色烟雾在火光中摇摆翻腾，罩住了整片冻原，这舞台的帷幕，仅有大地一位演员。陆启明发现自己已经站起身来。老人铁一般瘦削的身影被映得赤红，雪原上的一切都在飞速地离陆启明而去，只有那颗不规则的巨大心脏在搏动。闪烁的岩浆流挟着浓烟沿着山脊流淌，扑面而来的高温与气浪让陆启明无需借用黑体辐射的铁律也能感知到其磅礴的能量。他幻想着自己是在宇宙中心蜷缩着的光的婴儿，无声的啼哭使无数恒星为之黯淡。一切太安静了，出奇地安静。强烈的眩晕感让陆启明有那么一瞬间怀疑这一切的真实性——安静的婴儿，无声的啼哭，就像一场梦一般。 就像一场栖息在心底的、遥远的梦。 陆启明似乎又回到了那天傍晚，窗外的街道如玩具般被撕裂开来，那是他每日上学都必经的街道。他眼睁睁地看着一辆印着汰渍洗衣液广告的双层公交车失速坠入，后排乘客在消失在视线内的那一刻摇下车窗。他小时候很爱弹钢琴，他喜欢听那些由小小的黑白琴键交织而成的宏伟乐曲，喜欢榔头轻击在琴弦上发出的清脆乐音。钢琴猛然倒地，琴键砸向地面的刺耳声音让他吓了一跳。父母抱着他冲出了楼房，一台坠落的空调外机却夺去了他最好的朋友的生命。轰然倒塌，烟尘弥散，夕阳的余晖穿不透这滚滚浓烟，他什么也看不见。 在高考填报志愿的时候，他不加思索直接选择了地球物理专业。他常常梦见那个傍晚，那辆公交车，那个最好的朋友。琴弦崩坏的杂音让他辗转反侧，是啊，他畏惧着大地，怕得发抖。哺育一切的大地，势如洪流般摧毁一切的大地，是一种怎样的存在？ “别盯着火山口看太久，很伤眼睛的”。老人轻轻叹了口气，丢给陆启明一副墨镜，示意他在身旁坐下，他知道陆启明的眼中闪烁着的是什么。“三十年前的我和你如出一辙，那时候地质学的发展已经趋于停滞，任何对于解读长程地质活动的努力均以失败告终，再也没有新的理论被提出了。这领域越是深入，你越会觉得，其实自己对地球一无所知，直到我遇见了你的导师，”老人抬起头，远处的火光在他的眼中跃动。 “是时候给你讲讲落日工程的故事了。” 三十年前，科学界已经掌握用可控小型核爆与特殊材料“糖衣”稳定制造高密度中子材料的技术。核爆产生的巨大向心压力，被“糖衣”均匀地分配至里面包裹的物质表面，得到的物质甚至能在固态的岩石中下沉。后来的落日一号至计划发射的落日十号飞船的主体正是这种材料，只不过发射的目标不是星辰大海，而是地心深处。 陆启明对这个故事的开头再熟悉不过。最美丽的花草都被人们放在肃穆的落日六号纪念碑前，透过树荫的霞光将纪念碑的影子拉得狭长。纪念公园离他的大学很近，他闲暇时常去那里坐坐。秋日的公园宁静而祥和，要是迷失在地心的落日六号领航员沈静前辈也能伸出手指轻抚这里的微风，那该多好。但令人遗憾的是，落日七号至十号却因为工程原因被无限期地搁置。 “我想告诉你的，是在落日一号之前的那些故事。” “三十年前，我和你的导师相遇了。当时你的导师正在实验室里对着几篇打印出的论文发火，它们是其他学者发表在地质预测会议上面的。我翻了翻这几篇论文，都是一些对于现有基于地表观测数据的模型的精细修改。我记不太清这些论文的具体细节了，听说过本轮和均轮吗？” 陆启明摇头。老人挥了挥手，“也罢，现在还记得这几个词的都成老古董了。只是经过那几篇论文的轮番修改，原本的模型已经变得臃肿不堪。他当时都不屑于复现那些论文，我跟另外几位博士在科研之余试了试，发现这些修改确实在1到2年的周期内在划定的小规模区域内都能达到非常精确的预测结果，但一旦将时间跨度拉长，误差就会大到和随机无异了。” 清冽的月光织出一条白银缎带，泛着微微深红的火山岩尚有余温，大地似乎又沉沉睡去。“你的导师是对的，他的直觉总是能达到令人恐怖的准确率。我们发现理论的每次预测失效都在新出现的大火山的活动周期内，一旦产生了这样的偏差，后续预测便再难准确。” “后来，我带他来这个远在北极圈内的科考站逛逛。那次我们在这里待了老长一段时间，这儿可是潜心研究的好地方，不过你的导师似乎有些别的看法…直到有一天，我们近距离目睹了法格答尔火山的喷发。” “尽管那一次的喷发比我们刚刚看到的规模要小不少，但他却直接坐在地上，望着火山口沉默良久，初春时这里的积雪都还没完全化干净。当我想从包里拿出一张折叠椅递给他时，他回头直勾勾地看着我。” “他少见地直呼我的名字，‘也许我们的方向一直错了，’他支起身来，我清晰地记得他的裤子被体温融化的积雪沾湿了大片，但他却将身体挺的笔直，‘我们这么多年，这么多学者观测到的数据都只不过是…’” “….都只不过是地核之中岩浆和铁镍流体相互作用在地表上形成的的具象，对它们的测量再如何精确，也仅仅是在肢体末端测量人的脉搏而已。”陆启明轻轻点头，导师的音容相貌又重被从记忆中拾起，他不由地长叹一声。 “精妙的比喻。正是怀揣着这样的想法，国家地核物理实验室成立了，你的导师担任第一任首席科学顾问。他们规划着设计一系列耐极高温、高灵敏度的流体动力学探测器，并将它们发往地心，通过不受干扰的中微子通信收集数据，进而设计数学模型尝试推算整个地球的地质运动。这个计划后来更名为，落日工程。” “啊，但我记得落日工程的第一任 CTO 是…” 老人摇了摇头，“当落日工程启动的时候，他已经离我们而去”。 陆启明抬头望向天空，火山的余烬已然褪去，在这里能看见北半球最为浩瀚的星空。参宿四和参宿七张成一张巨弓，湛蓝的三颗腰带正如蓄势待发射向大犬座的弓箭——陆启明很喜欢将它们当作弓箭。天狼星无疑是大犬座中最耀眼的一颗，群青色的辉光弥散在夜幕中。银河如天龙一般横跨苍穹，无数恒星的色彩穿透星云凝固在整片夜空上。陆启明深知自己正处于远离城市光源的荒原，在这片静谧之地，他的心情却波澜起伏。 第二天清晨，陆启明背上背包早早地就出发了。老人又斟了一杯热茶为他送行。“祝愿你能在这里找到导师毕生追求的东西。”临行前老人意味深长地看着他。 小屋冒出的一缕炊烟让陆启明忽然有种言说不出的感动，陆启明反复品味着老人的目光。","link":"/2024/03/24/Fragment-of-my-Fantasy/"},{"title":"Pushdown Automata and Context-free Grammar","text":"Pushdown Automata下推自动机可以看作是 NFA 加入栈后的拓展版本。与 NFA 相比，PDA 的定义中多了一个“栈”的概念，一个 PDA 由六元组 $(Q, \\Sigma, \\Gamma, \\delta, q_0, F)$ 组成。其中： $Q, \\Sigma, q_0, F$​ 与 NFA 的定义完全一致，它们分别表示状态，字符集，起始节点，接受节点集。 $\\Gamma$ 是栈字符集，它规定了栈中的每个元素可能是什么。我们常常通过往栈中压入或者弹出一个 $ 来确保当前栈是空的。 $\\delta$ 同样是转移函数，但它与 NFA 的区别是引入了栈的状态。$\\delta$ 函数接受当前状态、当前栈顶以及一个字符（当然，可以是空串 $\\epsilon$），它的输出是一个目标节点以及对当前栈的操作（不从栈顶读字符并压入一个字符、弹出一个字符、更改栈顶字符或者保持栈不动）。更为形式化地说，$\\delta$ 的定义是 $Q\\times \\Sigma_{\\epsilon}\\times \\Gamma_{\\epsilon}\\to Q\\times \\Gamma_{\\epsilon}$​（输入栈顶即将被替换的那个字符，输出新的栈顶）。 我们称字符串 $w$ 可以被这个 PDA 识别，当且仅当存在一系列状态 $s_0, \\cdots, s_m$ 以及栈构成的字符串 $t_0, \\cdots, t_m$，使得 $s_0 = q_0, t_0=\\epsilon$：一开始在起始节点；栈是空的 对于每个 $i= 0, 1, \\cdots, m-1$，存在 $a, b\\in \\Gamma_{\\epsilon}$，以及 $r\\in \\Gamma^*$ 使得 $t_i=ar, t_{i +1}=br$。且 $(s_{i+1}, b)\\in\\delta(s_i, w_{i+1},a)$。注意 $a, b$ 可以是空的，这就完成了对栈的操作。 $s_m\\in F$​，即必须在接受节点结束。 Context-free Grammar所谓上下文无关语法就是“只能通过一定规则生成”的语法。它的形式化定义由四元组 $(V,\\Sigma,R,S)$ 构成，其中： $V$ 表示变量集合。所谓“变量”，在这里指的是满足特定规则的某个字符串（可以看作里面存的就是一个字符串，但是必须满足某些限制） $\\Sigma$ 表示字符集合，它规定了字符串中可能出现的所有字符。 $R$ 是规则集合，它规定了 $V$ 中变量必须服从的规则，每条规则会将一个 $V$ 中的变量和一个包含变量以及字符的字符串结合起来。或者它也可以看作若干条“文本替换规则”，即每次将当前字符串中的一个变量替换为另一个字符串（可能包含变量）。 $S\\in V$ 表示起始变量。 我们称字符串 $w$ 能被此语法生成，当且仅当从 $S$ 能导出字符串 $w$。举个例子，考虑下面的上下文无关语法：$$G=(\\{S\\}, \\{a, b\\}, R,S)\\\\\\quad R: S\\to aSb\\ |\\ SS\\ |\\ \\epsilon$$ 它能生成 ab，abab，aabbab 等等字符串。 Corelation事实上，下推自动机和上下文无关语法是等价的。即：任意下推自动机能表示的语言都能通过某种上下文无关语法生成，任意上下文无关语法都能对应一个下推自动机。证明由两个方向进行： 1. 任意上下文无关语法都对应一个下推自动机。 2. 任意下推自动机都对应一个上下文无关语法。 可以发现，1 是较容易证明的。构造自动机的思路是，先让自动机不接受任何输入，生成所有可能的字符串堆在栈里（即每一种在自动机上的走法结束后，栈中留下的都是一种可能的字符串）。然后自动机开始接受字符串，将其与当前栈顶比较，只有二者完全相同才弹出栈。 比如上面的那个例子，对于它我们可以构造出如下自动机：用 $x, y \\to z$ 表示接受字符 $x$，取出栈顶并确认其为 $y$，向栈压入 $z$。 起始节点 $q_0$，向节点 $q_1$ 连边 $\\epsilon, \\epsilon\\to \\text{\\$}$，意思是往当前栈中压入一个特殊字符用于判断栈是否为空。 节点 $q_1$ 向节点 $q_{loop}$ 连边 $\\epsilon, \\epsilon \\to S$，这是因为起始字符是 $S$，意思是让当前字符串有一个字符 $S$。 $q_{loop}$ 的连边有两种： 如果栈顶和接受字符串的第一个字符相同，那么弹出栈顶，对应向自己的连边 $a, a\\to \\epsilon $ 以及 $b, b\\to \\epsilon$。 应用一条规则。比如规则 $S\\to aSb$，如果栈顶为 $S$，则弹出栈顶，并相继压入 b，$S$​，a。 $q_{loop}$ 向接受节点 $q_{accept}$ 连边，弹出特殊字符用来确保当前栈为空。 下图是规则 $S\\to aTb|b, T\\to Ta|\\epsilon$ 的例子。 接下来我们讨论关于 2 的证明。不妨假设这个自动机有 $k$ 个节点，我们生成 $k^2$ 个变量 $A_{pq}$，这里 $p,q$ 都是节点的编号，它用于表示所有从 $p$ 出发，并且出发时栈为空，能够到达 $q$ 且此时栈为空的字符串。那么，我们可以对其生成两种类型的规则。 存在一个中间节点 $r$，使得自动机运行到节点 $r$ 时栈为空，那么根据定义可以构造出一条语法 $A_{pq}=A_{pr}A_{rq}$。 如果存在字符串 $w$ 能从 $p$ 走到 $q$，拿出 $w$ 的第一个字符 $a$ 以及最后一个字符 $b$，并且记录下 $w$ 第一步走到的节点 $r$ 以及到达 $q$ 之前的节点 $s$，生成语法 $A_{pq}=aA_{rs}b$。由于 $\\Sigma, Q$ 都是有限的，因此这样生成的规则也只有有限多条。 通过对字符串 $w$ 的长度 $|w|$ 归纳，可以很方便地证明任意能在这个自动机上跑的字符串都能被我们构造出的语法生成。 对上下文无关语法的 Pumping Lemma Pumping Lemma 若 $A$ 是一种上下文无关语法，则存在一个数 $p$，使得对于 $A$ 能生成的任意字符串 $s$，如果 $|s| \\ge p$，那么 $s$ 可以被划分为 $5$ 个部分 $uvxyz$，使得 对于任意的 $i\\ge 0$，$uv^ixy^iz\\in A$。 $vy$ 不为空。 $|vxy|\\le p$。 只要 $s$ 足够长，那么生成出 $s$ 这个串对应的树形结构的深度就可以有保证。而这个深度一旦超过了点数，根据抽屉原理其中必然存在两个相同的变量（下图中的 $N$）。将深度更浅的 $N$ 对应的子树复制到深度更深的 $N$ 中，得到的串应当仍然满足上下文无关文法要求。","link":"/2024/03/15/Pushdown-Automata-and-Context-free-Grammar/"},{"title":"Some warm tips","text":"其实主要是一些页面元素的备忘录，我太容易搞忘了 0. 0 这个主题好像是支持 Bulma 的，也就是说可以直接向 .md 文件里面插入它支持的 html 元素。 分栏显示 这里是第一列 这里有一些内容 html code >folded123456789101112131415&lt;div class=&quot;columns&quot;&gt; &lt;div class=&quot;column&quot;&gt; &lt;article class=&quot;message is-primary&quot;&gt; &lt;div class=&quot;message-header&quot;&gt; &lt;p&gt;这里是第一列&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;message-body&quot;&gt; 这里有一些内容 &lt;/div&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; 哇，这里能递归吗 &lt;/div&gt;&lt;/div&gt; messagemessage 一共有 $7$ 种，它们分别是 dark, primary, link, info, success, warning 以及 danger。值得一提的是可以在 class 内加入 message-immersive，它会变得非常帅，比如这样 此处的代码为 12345&lt;article class=&quot;message message-immersive is-primary&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; 此处的代码为... &lt;/div&gt;&lt;/article&gt; 小标签页 第一个 第二个 我在第一个标签页里 我在第二个标签页里 12345678&lt;div class=&quot;tabs is-boxed is-fullwidth&quot;&gt; &lt;ul class=&quot;mx-0 my-0&quot;&gt; &lt;li class=&quot;is-active&quot;&gt;&lt;a href=&quot;#first&quot;&gt;第一个&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#second&quot;&gt;第二个&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div id=&quot;first&quot; class=&quot;tab-content&quot;&gt;我在第一个标签页里&lt;/div&gt;&lt;div id=&quot;second&quot; class=&quot;tab-content is-hidden&quot;&gt;我在第二个标签页里&lt;/div&gt; 代码样式可以分别制定每个代码块是否折叠，方式是采用 hexo 提供的内嵌代码，它长这样 123{% codeblock &quot;optional file name&quot; lang:code_language_name &gt;folded %}...code block content...{% endcodeblock %} 插入图片在文件中加入如下代码 1{% asset_img image.jpg 200 400 This is an image %} 其中 200 400 的作用是限制图片大小。","link":"/2024/03/14/Reminder/"},{"title":"Tacos lab1 directions","text":"一点碎碎念操作系统的 lab 相比于 ics 的 lab 难度明显上了一个档次，里面可能踩的坑实在是太多了！！而且对于新编写出的 rust 版本的操作系统，没有前人的足迹可以追寻，在写的时候也可能出现各种各样莫名其妙的问题。这篇文章权当一个小小的指北吧。我只会列出每个任务的设计思路。 首先我想列出在写这个 lab 之前，我们应该达成的几点“共识”（要不然这 lab 没法写了） 多线程中常用 Mutex&lt;&gt; 来确保对关键数据访问的独一性。它有一个优点是不需要 Mutex 本身可变就可以修改里面的数据，同时可以很安全地被多个线程访问。 std 是没法用的，但是 rust 很贴心地帮我们在 alloc 里面实现了很多有用的工具，比如 Vec, BinaryHeap, BTreeMap 等等。需要注意的是 rust 中没有与 multiset 类似的数据结构。 在这个 lab 中，我们只需要考虑单核 cpu 的情况。虽然整个系统看上去很多很多部分都是并行的，但实际上这些代码在某个时刻只会有一行正在被执行。 这个 lab 的核心是维护不同线程的切换，线程的切换涉及以下几种情况： 主动调用了 schedule 函数：将当前线程放回 ready 线程列表中，切换上下文，将执行权交给下一个线程。 一个线程被唤醒了，且它比当前正在运行的线程具有更高的优先级。 程序主动更改了一个线程的优先级（注意：这个线程一定是当前正在运行的线程！这个 lab 里面不需要实现更改其它线程的优先级），并且使得处于 ready 列表的线程中，存在一个线程的优先级更高。 一个线程请求了一个未被释放的锁。 time interrupt。在内核中有一个计时器与一个切换阈值，如果距离上次切换的时间长于这个阈值，那么操作系统会触发一次 time interrupt 陷阱。如果不关闭 time interrupt，这个陷阱内会执行一次 schedule。因此如果要从系统层面上确保当前操作是原子的，需要关闭 time interrupt（关上这个之后甚至连 tick 都不会调用）。每个线程都有自己独立的 time interrupt 状态。在多核 cpu 上频繁地关 interrupt 不是一个好习惯，因为所有 cpu 都会停下，效率很低。不过我们只需要考虑单核的情况，因此该关还是关吧。 关于 CondVar：在使用互斥锁的场景下，如果我们手持一个锁，但同时又想要等待另外一个锁被释放，此时有两种想法： 不释放当前手持的锁，等待被释放的锁。好处是不会产生数据竞争，但是此时任何其他需要第一个锁的线程都会被阻塞，这样效率不高。 释放当前手持的锁，等待被释放的锁。这样做有一定风险：等待此线程持有的锁的那些线程有可能会在中间插入，从而导致数据竞争。 CondVar 就是专门针对这样的场景设计的工具，核心部分由三个函数组成： wait(cond, guard) 这里 cond 是条件变量，guard 是锁，且必须处于持有状态。这个函数可以理解为“释放锁 guard，等待条件变量 cond 被触发，再重新获取锁 guard” 的原子过程，尽管其内部实现并不是原子的。 notify_one(cond) 通知一个等待这个条件变量触发的线程。如果没有线程在等待，那么这次触发将会被丢失。 notify_all(cond) 通知所有正在等待这个变量触发的线程。 可以说从头到尾，这个 lab 有几个核心之处： src/thread.rs，这个文件内实现了 thread 的所有接口。我修改了 wake_up, sleep, get_priority, set_priority 这些函数。我们需要实现让线程能非阻塞 sleep，以及能够设置当前线程的优先级。 src/thread/manager.rs，这个文件内实现了函数 schedule，可以说这是整个 lab 最为核心的函数：操作系统从 ready 列表中拿出优先级最高的线程，停止执行当前线程，切换上下文并移交执行权。 src/thread/imp.rs，这个文件内是线程各项属性的定义，为了实现 task2 的第二部分我们需要对线程本身的结构体做出很多修改。 已经实现好的各种锁的代码。由于我们需要向线程切换以及唤醒线程中加入优先级的概念，因此所有涉及“唤醒等待线程”的地方都要考虑它们的优先级。 最后说一说调试方法。我还是最喜欢直接 kprintln。可以在 schedule 函数、设置优先级这些地方输出当前线程的信息，非常方便。由于 rust 的 release 编译非常非常慢，因此要调试测试数据的时候可以先加入参数 --dry 显示调用的命令，然后在根目录下手动执行这个命令。这样可以快很多。 比如，如果我想要调试测试点 priority-preempt，我就可以在 tool 文件夹里面输入命令 cargo tt -c priority-preempt --dry，它的输出是这样的 在根目录下运行命令 cargo run -r -F test-schedule -- -append priority-preempt 就可以了。-q 参数可删可不删，我觉得看着编译信息有一种它正在工作的感觉。 Alarm Clock这个 task 的意思是需要让我们更改原有的 sleep 函数。这个函数默认的实现方式是每次被唤醒的时候就看看当前时刻有没有到目标时刻，如果没有到话就 schedule，让 cpu 执行其它线程。我们需要把它改为非阻塞的实现方式。 实现方式也很简单，可以发现整个操作系统有一个增加当前时刻的函数 tick，我们只需要让这个函数每次被调用的时候都检查一下当前正在等待的线程。可以用 BTreeMap&lt;i64, Vec&lt;Arc&lt;Thread&gt;&gt;&gt; 将线程唤醒时间与线程本身关联起来，每 tick 都检查一下当前正在 sleep 的线程列表。 Priority SchedulingBasic Priority Scheduling这里我们需要实现简单的线程优先级系统，为了确保我们对于优先级的理解正确，以下有几点共识： 操作系统在任意时刻正在运行的线程都一定具有最高的优先级。不存在一个有着更高优先级的线程位于等待列表中。 对于相同优先级的线程，在 schedule 中需要采用先进先出的策略：先被添加到 ready 列表中的线程应当被优先唤醒。 在信号量中优先唤醒优先级高的线程。但是对于相同优先级的线程，它们被唤醒的顺序可以是随机的。 为了让程序有更高的运行效率，你可能会想到用 BinaryHeap 实现取出优先级最高的线程，但是相信我，下一个任务你会把它改回 Vec 的（或者 VecDeque） 推荐在写这个部分之前先认真思考一下这几个问题： 每个线程可能有哪些状态？ 什么时候线程有可能会调用 set_priority？需不需要考虑那些正在被 Blocked 的线程？ 什么时候最高优先级的线程会发生变化？ 你会需要修改 src/thread/scheduler/fcfs.rs 文件，可以照着里面已经有的那个东西实现一个优先队列版本的。 值得一提的是我发现 src/sync/sema.rs 中对 up 函数的默认实现似乎有点问题： src/sync/sema.rs1234567891011121314/// V operationpub fn up(&amp;self) { let old = sbi::interrupt::set(false); let count = self.value.replace(self.value() + 1); // Check if we need to wake up a sleeping waiter if let Some(thread) = self.waiters.borrow_mut().pop_back() { assert_eq!(count, 0); thread::wake_up(thread.clone()); } sbi::interrupt::set(old);} 这里实际上是不能 assert 的：唤醒线程并不代表立即运行这个线程，而 count 只有在请求锁的线程开始运行的时候才会 $-1$。因此如果执行权没有被交给被唤醒的线程，进行相邻的两次 V 后 count 确实可能非 $0$。所以这里的 assert 需要删去。 Priority Donation聪明的你在写完上一个关于优先级的任务之后也许会有这样的疑问：诶？这样的规则是不是非常容易导致死锁？文档中描述了这样一种情况：假设现在有高优先级线程 H，中优先级线程 M 以及低优先级线程 L，如果 L 持有一个锁，而 M 正在运行，那么 L 这个线程无论如何也不会被启动（因为 M 的优先级高于它，根据优先级策略 M 应该被优先执行），如果 H 需要 L 的锁，那么它就完蛋了。 为了让这种情况不要发生，文档中提出了一种“线程捐赠”的机制：如果线程 A 要请求线程 B 的锁，它就会把自己的优先级“捐”给 B：B 此时的优先级应当变为 A，B 两者的较大值。我们将这个值称为“有效优先级”。如果 B 又开始请求线程 C 的锁，那么 B 就会把自己的有效优先级捐给 C，此时 C 的优先级就是 A，B，C 三者的最大值。 你仔细思考了一下，发现很难在信号量这种多对多的场景实现这样的线程捐赠机制：你怎么知道当前线程在 P 完之后或者 V 完之后会不会继续管这个信号量？即使它不会管，也有许许多多其它的线程有可能会 V。那这种情况是谁捐给谁呢？ 答案是其实我们不需要管这种情况。只需要实现最简单的 sleep 内（不是第一个任务里面的那个 sleep）的优先级捐赠情况就行了，它相当于只能为 0 或者为 1 的信号量。sleep 内是一对多的（一个 holder，多个 waiter）。 如果把线程捐赠的网络画成一张图，首先它一定是一个 DAG，再思考一下会发现它一定是一棵树：每个线程只可能等待另外一个线程，因为一旦 require 失败它就会 Block 直到这个锁被释放。因此我们需要实现的东西就是维护这么一棵捐赠的树形结构：可能会连一条新的边，也有可能断开原有的边，每个点的有效优先级是子树内的最大值。如果你非常厉害，那么不妨来试试 lct 吧。 需要注意的是由于我们可能会请求一个正在 sleep 或者正在被阻塞的线程所持有的锁，所以那些没有运行的程序的优先级，乃至整条链上的优先级都可能会被改变，这也是上一个任务中不能使用 BinaryHeap 的原因：它是不支持修改的。 另一件令人迷惑的问题是，我们需要在即使只有 Arc&lt;Thread&gt; 的情况下也能对此线程内的依赖关系进行修改，这就要求我们给那些可能被修改的数据套上互斥锁（RefCell 是不行的，因为它不 Sync，多线程访问的话 rust 会觉得不安全），这是相当奇怪的一件事：在上锁的过程中会涉及优先级捐赠，但实现优先级捐赠的部分却需要上锁。实际上在涉及到更改捐赠树的操作时我们会关闭 interrupt，因此可以确保访问的唯一性，但是为了通过编译仍然需要在相关的数据结构外套上一层 Mutex。 最后聊一聊 acquire 和 release 内具体要干的事情。","link":"/2024/03/18/Tacos-lab1-directions/"},{"title":"Simplex and Linprog","text":"线性规划基础线性规划指的是目标函数以及约束条件都是线性函数时的最优化问题。对于最一般的情况，我们可以用如下的形式刻画要解决的问题： 目标函数： $c(x_1, \\cdots, x_n)=\\sum_{j=1}^n c_j x_j$，我们想要最大化（或者最小化也可以）它，这里 $c_i$ 可正可负。 约束条件： $\\sum_{j=1}^n a_{ij}x_j\\le b_i$ （当然，$\\ge$ 或者 $=$ 也是可以的，它们都可以用 $\\le$ 表示）。有 $m$ 条约束条件（$a$ 的下标就是这么来的）。 对于变量的非负性约束：有些 $x_i$ 可以随便取，但是有些 $x_i$ 不能小于 $0$。（其实规定所有变量必须不低于 $0$ 是等价的） 这个模型有些复杂，它可以被规约到一个难度完全相同，但是表达形式更简单的问题。我们称这种最简形式为标准型： 目标函数：$c(x_1, \\cdots, x_n)=\\sum_{j=1}^n c_jx_j$​，我们想要最大化它。 约束条件：$\\sum_{j=1}^n a_{ij}x_j=b_i$。（全部改成 $\\le$ 则被称作松弛型线性规划） 对于变量的非负性约束：$\\forall i, x_i\\ge 0$​​​。 之后将系数 $a_{ij}$ 合并为矩阵 $\\mathbf A\\in M_{m\\times n}$，将目标函数的系数合并为列向量 $\\mathbf c=(c_1, \\cdots, c_n)^\\top$ 一些定义 可行解：和看起来的意思一样，指的是一组满足所有约束条件的解。 可行域：所有可行解组成的集合，它肯定是一个凸集。 最优解：让目标函数取到最值时对应的可行解。可能有多个。 闭上眼睛感受一下，这个线性规划问题的解看起来就会满足一些性质（后面会严格证明） $x_1, x_2, \\cdots, x_n$ 中所有在目标函数中系数不为 $0$ 的变量构成了一个高维的空间，而可行域则在这个空间内一个较低维的子空间内。 如果把每条约束条件看成一个低维的子空间（比如二维空间内的直线），那么可行域的每个端点都是若干个这样的子空间的交点。 最优解一定可以在可行域的某一个端点取到。 可以利用爬山的方式一步一步想最优解靠近（每次从当前的顶点挪到一个与它相邻的，但是更优的顶点） 由此诞生了另一些定义 另一些定义 基本解：在顶点位置，但不一定满足非负性约束的解。 基本可行解：是基本解，并且满足非负性要求。 接下来我们讨论单纯形。首先让我们从一个例子开始。 考虑 $x_1, x_2, x_3$ 所在的空间 $\\mathbb R^3$，上面的约束条件可以看作在这个空间内圈定了一个区域。单纯形算法用基变量和非基变量两个概念将凸包的顶点和所有变量关联了起来：任意选定系数矩阵 $\\mathbf A$ 极大的线性无关的若干列（对应的变量称为基变量），令没有选中的列对应的变量（称为非基变量）取值为 $0$，方程 $Ax=b$ 的解是唯一的，并且： 这个解一定对应到了凸包上的一个顶点。 凸包上的每个顶点都能这个样子解出来。 比如上面的例子，如果我们选定第 $2, 4, 5, 6$ 列，令 $x_1=x_3=x_7=0$，则可以解出唯一的解 $(0, 2, 0, 2, 2, 3, 0)$。它对应顶点 $(0, 2, 0)$。 为了说清楚 $\\mathbf A$ 与整个凸包的关系 ，此时我们需要解决的问题是： 证明任意选择 $\\mathbf A$ 的线性无关的若干列，直接令其余变量为 $0$，得到的解对应了一个顶点。 证明对于凸包的每一个顶点，都对应了 $\\mathbf A$ 列向量的一个极大线性无关组。 一旦证明了这两点，我们就可以将不好处理的求顶点问题转化为便于计算的解方程问题。 Q：为啥得到的一定是一个顶点？证明：如果得到的不是顶点，对于选定的 $\\mathbf A$ 的基组成的矩阵 $\\mathbf B$，方程 $\\mathbf Bx=\\mathbf b$ 得到的解 $\\mathbf x=[x,0]^\\top$ 可以被两个内部点对应的解 $\\mathbf x_1, \\mathbf x_2$ 线性表出。由于 $\\mathbf x_1, \\mathbf x_2$ 的非基变量取值非负，并且 $\\mathbf x=\\lambda_1\\mathbf x_1+\\lambda_2\\mathbf x_2$，结合 $\\mathbf x$ 的非基变量等于 $0$ 可以知道 $\\mathbf x_1, \\mathbf x_2$ 的非基变量也必须为 $0$。但是，由于 $\\mathbf B$ 是满秩的，它的解唯一，也就是说 $\\mathbf x_1, \\mathbf x_2$ 的基变量取值完全相同，它们就是同一个点。因此解出的 $\\mathbf x$ 一定是顶点。 Q：为啥每个顶点都解得出来？更为严谨地说，我们想要说明的是这么一件事情：拿出凸包的一个顶点，随便解出一组解，如果在这个解中非 $0$，且在目标函数中系数为 $0$ 的变量对应的 $\\mathbf A$ 的列向量线性无关（这当然是能做到的），那么整个解中非零元素对应的 $\\mathbf A$​ 的列向量也一定线性无关。 证明这个东西的意义是，证明凸包上的每个顶点都可以被解出来。 证明： 反证。如果整个解 $\\mathbf x$ 中非零元素对应的 $\\mathbf A$ 的列向量 $a_1, \\cdots, a_k$ 线性相关，那么存在一组不全为 $0$ 的系数 $\\lambda_1,\\cdots, \\lambda_k$ 使得 $\\sum_{i=1}^k \\lambda_i a_i=0$。根据条件可知必然有至少一个在目标函数中系数不为 $0$ 的变量，其对应的 $\\lambda$ 也不为 $0$。对于除了 $a_1, \\cdots, a_k$ 以外的其余列，令它们对应的 $\\lambda$ 都是 $0$。这也就是说我们可以得到一个列向量 $\\mathbf \\lambda=(\\lambda_1,\\cdots, \\lambda _n)^\\top$，使得 $\\mathbf A(\\mathbf x+\\lambda)=\\mathbf b$。取一个很小很小的 $\\theta$ 可以使得 $\\mathbf A(\\mathbf x+\\pm\\theta\\lambda)=\\mathbf b$ 成立且 $\\mathbf x+ \\pm \\theta\\lambda$ 的每个元素都不小于 $0$。这说明 $\\mathbf x$ 对应的点可以被两个凸包内的点线性表示，它必不可能在凸包上。 单纯形有了上面的结论，剩下的过程就比较简单了。单纯形就是把上面的所有东西全部揉了起来。不妨设 $\\mathbf A$ 的秩是 $r$​。 单纯形 选取 $r$ 列作为基变量，其余列作为非基变量，可以解出一个顶点。单纯形法会从一个可行的顶点出发。 看看周围（指把一个基变量变成非基变量，把那个非基变量变成基变量，对应的顶点）有没有其他顶点更优秀，如果更优秀就这么搞。 重复上一步，直到找不到更优秀的相邻顶点。 又一些定义 基：$\\mathbf A$ 列向量的极大线性无关组。 基变量：基对应的变量。 非基变量：除了基变量之外的变量，我们认为它们一直都是 $0$。 基本解：指满足约束条件但不一定满足非负性条件，且非基变量全为 $0$ 的解。 基本可行解：在基本解的基础之上满足非负性条件的解。 可行基：基本可行解对应的基。 对于不需要初始化的松弛型线性规划（就是每个约束条件都是 $\\le$），我们可以往里面添加 $m$ 个辅助变量 $x_{n+1}, \\cdots, x_{n+m}$，将其变为标准型线性规划。因此这个时候的一个基本可行解就是 $(0, 0, \\cdots, 0, b_1, \\cdots, b_m)$。 转轴接下来问题来到了如何找到相邻的更优秀的顶点以及如何挪过去。 继续考虑上面那个例子，假设我们已经选取了基变量 $x_1, x_4, x_6, x_7$，并且已经知道非基变量 $x_2, x_3, x_5 =0$。对于 $x_3$，列 $a_3$ 与 $a_1, a_4, a_6, a_7$ 线性相关，有$$a_3=0a_1+1a_4+1a_6+1a_7$$这也就是说 $0a_1+0a_2-1a_3+1a_4+0a_5+1a_6+1a_7=0$，将前面的系数提取为 $\\lambda=(0, 0, -1, 1, 0, 1, 1)^\\top$，有 $\\forall \\theta, \\mathbf A(\\mathbf x-\\theta\\lambda)=0$。我们可以通过选取合适的 $\\theta&gt;0$，使得某个已有的基变量在解 $\\mathbf x-\\theta\\lambda $ 中变为 $0$，$x_3$ 的系数变为 $\\theta$，这样就达到了“换基”的目的：我们将 $x_3$​ 从非基变量换成了基变量，而将某一个基变量给换了出去。 考察换基前后目标函数的变化。一开始是 $\\mathbf c^\\top \\mathbf x$，现在变为了 $\\mathbf c^\\top (\\mathbf x-\\theta\\lambda)$，变化量为 $-\\theta\\mathbf c^\\top\\lambda$。对于每个非基变量（比如上面的 $a_3$），我们都可以计算出这个变化量。如果所有变化量都 $\\le 0$，这说明我们已经找到了最优值，算法终止。否则根据爬山的策略，我们应该找到变化量最大的，进行一次换基操作。 $\\theta$ 的选取需要满足 $\\mathbf x - \\theta\\lambda$ 仍然全部非负。这就要求对于每个 $i\\in \\mathbf B, x_i-\\theta\\lambda_i\\ge 0$。这里 $\\mathbf B$ 指的是所有基变量的下标集合。如果 $\\lambda_i&lt;0$，那么此时不会出任何问题，可以发现直接令 $\\theta=\\min_{\\lambda_i&gt;0}\\frac{x_i}{\\lambda_i}$ 就是安全的。 接着考虑 $-\\theta\\mathbf c^\\top\\lambda$，在 $\\lambda$ 中当前非基变量对应的值为 $-1$，其余位置只有基变量处的取值非 $0$。记行向量 $\\bar{\\mathbf c}$ 分别表示每个变量如果换入基变量，可以让答案增加多少（当然，对于当前的基变量，这个值为 $0$），由于 $\\mathbf B^{-1}\\mathbf A$ 刻画了此时 $\\mathbf A$ 的每一列在基 $\\mathbf B$ 下的坐标（其实就是 $\\lambda$），结合上面的过程我们有 $\\bar{\\mathbf c}=\\mathbf c^\\top-\\mathbf c_B^\\top \\mathbf B^{-1}\\mathbf A$。这里 $\\mathbf c_B^\\top$ 表示只保留 $\\mathbf c$ 中基变量对应的系数，其余系数填 $0$。 对偶线性规划现在有这么一个线性规划：最小化 $7x_1+x_2+5x_3$，满足约束 $\\begin{gathered}x_1-x_2+3x_3\\geq 10\\\\5x_1+2x_2-x_3\\geq 6\\\\x_{1,2,3}\\geq 0\\end{gathered}$。可以发现，这个线性规划相比于松弛形式的线性规划翻转了最大/最小化，同时原来的 $\\le$ 也变成了 $\\ge$。 聪明的你也许会有这样的想法：能不能直接把这些方程组合一下？比如，由于 $x_{1, 2, 3}\\ge 0$，所以一定有 $7x_1+x_2+5x_3\\ge x_1-x_2+3x_3\\ge 10$。把这三个方程组合一下能否得到更紧的下界呢？ 这等价于给这两个方程分配变量 $y_1, y_2$，需要满足 $\\begin{gathered}y_1+5y_2\\le 7 \\\\ -y_1+2y_2\\le 1 \\\\ 3y_1-y_2\\le 5\\end{gathered}$，并且 $y_1, y_2$ 非负，同时最大化 $10y_1+6y_2$。这就是原线性规划的对偶问题。通过互松弛定理可以证明，原线性规划的最优解和对偶线性规划是相同的。由于对偶线性规划可以交换约束的数量和变量的数量，因此在解决某些问题的时候非常有用。 一些小练习 $A,B$ 两个人在洞中发现了 $n$ 个石头，第 $i$ 个石头对于 $A$ 来说价值为 $A_i$，对于 $B$ 来说价值为 $B_i$。石头是可以切割的，并且价值与其体积成正比。现在$A,B$要分配这些石头，要求它们两个人最终得到的价值相同，问这个价值最大可以是多少 $$n\\leq 50, 0\\leq A_i,B_i\\leq 100$$ 源点和汇点唯一，其余每个点的流入流量必须等于流出流量，每条边有流量上界，问从源点到汇点的最大流。 最小费用流。即在最大流的基础之上，要求费用之和最小。每条边的单位流量有费用。 给一张 $n$ 个点的带权无向图，边 $u,v$ 的权值为 $w_{u,v}$，可以随意增加或者减少若干条边的边权，代价为边权的变化量。要求进行操作之后任意两点间直接相连的边的长度不超过两点之间的最短路，求最小代价。 给出三个长度为 $n$ 的数组 $a_i,b_i,c_i$，每次询问给出两个数 $s,t$，求一组非负实数 $x_i$，满足 $\\sum_{i=1}^na_ix_i=s,\\sum_{i=1}^nb_ix_i=t$，同时最大化 $\\sum_{i=1}^nc_ix_i$。对于每组询问输出答案，或者判断无解。$n\\le 10^5$，询问数不超过 $10^4$。","link":"/2024/03/28/Simplex-and-Linprog/"}],"tags":[{"name":"Automata","slug":"Automata","link":"/tags/Automata/"},{"name":"Theoretical Computer Science (TCS)","slug":"Theoretical-Computer-Science-TCS","link":"/tags/Theoretical-Computer-Science-TCS/"},{"name":"Operating System","slug":"Operating-System","link":"/tags/Operating-System/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"}],"categories":[{"name":"Theoretical Computer Science(TCS)","slug":"Theoretical-Computer-Science-TCS","link":"/categories/Theoretical-Computer-Science-TCS/"},{"name":"Configuration","slug":"Configuration","link":"/categories/Configuration/"},{"name":"Automata","slug":"Theoretical-Computer-Science-TCS/Automata","link":"/categories/Theoretical-Computer-Science-TCS/Automata/"},{"name":"Operating System","slug":"Operating-System","link":"/categories/Operating-System/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"}],"pages":[{"title":"About","text":"哇，恭喜你发现了这个神奇的角落！ 但可惜的是，现在这里还啥都没有…🥲","link":"/about/index.html"}]}